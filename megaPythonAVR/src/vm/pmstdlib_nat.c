#undef __FILE_ID__
#define __FILE_ID__ 0x0A
/**
 * PyMite std native function file
 *
 * automatically created by pmImgCreator.py
 * on Mon Sep  8 17:14:47 2008
 *
 * DO NOT EDIT THIS FILE.
 * ANY CHANGES WILL BE LOST.
 *
 * @file    pmstdlib_nat.c
 */

#define __IN_LIBNATIVE_C__
#include "pm.h"

/* From: ../lib/avr.py */
#include <avr/io.h>

PmReturn_t
nat___bi_abs(pPmFrame_t *ppframe)
{

    pPmObj_t pn;
    pPmObj_t pm;
    int32_t n;
    PmReturn_t retval = PM_RET_OK;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Raise ValueError if arg is not int */
    pn = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(pn) != OBJ_TYPE_INT)
    {
        PM_RAISE(retval, PM_RET_EX_VAL);
        return retval;
    }

    /* Push the absolute value onto the stack */
    n = ((pPmInt_t)pn)->val;
    if (n >= 0)
    {
        NATIVE_SET_TOS(pn);
    }
    else
    {
        retval = int_new(-n, &pm);
        NATIVE_SET_TOS(pm);
    }

    return retval;
    
}

PmReturn_t
nat___bi_chr(pPmFrame_t *ppframe)
{

    pPmObj_t ps;
    pPmObj_t pn;
    int32_t n;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Raise TypeError if arg is not an int */
    pn = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(pn) != OBJ_TYPE_INT)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Raise ValueError if arg is not int within range(256) */
    n = ((pPmInt_t)pn)->val;
    if ((n < 0) || (n > 255))
    {
        PM_RAISE(retval, PM_RET_EX_VAL);
        return retval;
    }

    /* Create char string from  integer value */
    retval = string_newFromChar((uint8_t const)n, &ps);
    NATIVE_SET_TOS(ps);
    return retval;
    
}

PmReturn_t
nat___bi_eval(pPmFrame_t *ppframe)
{

    PmReturn_t retval;
    pPmObj_t pco;
    pPmObj_t pfunc;
    pPmObj_t pnewframe;
    pPmObj_t pg = C_NULL;
    pPmObj_t pl = C_NULL;

    /* If wrong number of args, raise TypeError */
    if ((NATIVE_GET_NUM_ARGS() == 0) || (NATIVE_GET_NUM_ARGS() > 3))
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Raise ValueError if first arg is not a Code Object */
    pco = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(pco) != OBJ_TYPE_COB)
    {
        PM_RAISE(retval, PM_RET_EX_VAL);
        return retval;
    }

    /* If 2nd arg exists, raise ValueError if it is not a Dict */
    if (NATIVE_GET_NUM_ARGS() >= 2)
    {
        pg = NATIVE_GET_LOCAL(1);
        if (OBJ_GET_TYPE(pg) != OBJ_TYPE_DIC)
        {
            PM_RAISE(retval, PM_RET_EX_VAL);
            return retval;
        }
    }

    /* If no args are given, use the caller's globals for the function's */
    else
    {
        pg = (pPmObj_t)NATIVE_GET_PFRAME()->fo_globals;
    }

    /* If 3rd arg exists, raise ValueError if it is not a Dict */
    if (NATIVE_GET_NUM_ARGS() >= 3)
    {
        pl = NATIVE_GET_LOCAL(2);
        if (OBJ_GET_TYPE(pl) != OBJ_TYPE_DIC)
        {
            PM_RAISE(retval, PM_RET_EX_VAL);
            return retval;
        }
    }

    /* Create func from code object */
    retval = func_new(pco, pg, &pfunc);
    PM_RETURN_IF_ERROR(retval);

    /* Create frame from module object; globals is set to null */
    retval = frame_new(pfunc, &pnewframe);
    PM_RETURN_IF_ERROR(retval);

    /* TODO: Reclaim pnewframe's attrs dict created in frame_new */
    /*
     * By default use calling frame's attrs as local namespace.
     * This works for ipm because the interactive mode
     * needs a locals namespace that persists across calls to eval()
     */
    ((pPmFrame_t)pnewframe)->fo_attrs = NATIVE_GET_PFRAME()->fo_attrs;

    /* If 2nd arg exists, use it as the global namespace for the new func */
    if (NATIVE_GET_NUM_ARGS() >= 2)
    {
        ((pPmFrame_t)pnewframe)->fo_globals = (pPmDict_t)pg;

        /* If only globals is given, locals defaults to it */
        ((pPmFrame_t)pnewframe)->fo_attrs = (pPmDict_t)pg;
    }

    /* If 3rd arg exists, use it as the local namespace for the new func */
    if (NATIVE_GET_NUM_ARGS() >= 3)
    {
        ((pPmFrame_t)pnewframe)->fo_attrs = (pPmDict_t)pl;
    }

    /*
     * Set the fo_back frame so flow returns to eval()'s caller when completed.
     * Set the frame pointer so the new frame is interpreted immediately
     * after this function returns.
     */
    ((pPmFrame_t)pnewframe)->fo_back = NATIVE_GET_PFRAME();
    NATIVE_GET_PFRAME() = (pPmFrame_t)pnewframe;
    retval = PM_RET_FRAME_SWITCH;

    return retval;
    
}

PmReturn_t
nat___bi_globals(pPmFrame_t *ppframe)
{

    pPmObj_t pr = C_NULL;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 0)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Return calling frame's globals dict  on stack*/
    pr = (pPmObj_t)NATIVE_GET_PFRAME()->fo_globals;
    NATIVE_SET_TOS(pr);

    return PM_RET_OK;
    
}

PmReturn_t
nat___bi_id(pPmFrame_t *ppframe)
{

    PmReturn_t retval;
    pPmObj_t pr = C_NULL;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Return object's address as an int on the stack */
    retval = int_new((int)NATIVE_GET_LOCAL(0), &pr);
    NATIVE_SET_TOS(pr);

    return retval;
    
}

PmReturn_t
nat___bi_len(pPmFrame_t *ppframe)
{

    PmReturn_t retval;
    pPmObj_t ps = C_NULL;
    pPmObj_t pr = C_NULL;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Get first arg */
    ps = NATIVE_GET_LOCAL(0);

    /* Get the length of the arg based on its type */
    switch (OBJ_GET_TYPE(ps))
    {
        case OBJ_TYPE_STR:
            retval = int_new(((pPmString_t)ps)->length, &pr);
            break;

        case OBJ_TYPE_TUP:
            retval = int_new(((pPmTuple_t)ps)->length, &pr);
            break;

        case OBJ_TYPE_LST:
            retval = int_new(((pPmList_t)ps)->length, &pr);
            break;

        case OBJ_TYPE_DIC:
            retval = int_new(((pPmDict_t)ps)->length, &pr);
            break;

        default:
            /* If not a string or sequence type, raise TypeError */
            PM_RAISE(retval, PM_RET_EX_TYPE);
    }

    NATIVE_SET_TOS(pr);
    return retval;
    
}

PmReturn_t
nat___bi_locals(pPmFrame_t *ppframe)
{

    pPmObj_t pr = C_NULL;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 0)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Return calling frame's local attrs dict on the stack */
    pr = (pPmObj_t)NATIVE_GET_PFRAME()->fo_attrs;
    NATIVE_SET_TOS(pr);

    return PM_RET_OK;
    
}

PmReturn_t
nat___bi_ord(pPmFrame_t *ppframe)
{

    pPmObj_t ps;
    pPmObj_t pn;
    int32_t n;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    ps = NATIVE_GET_LOCAL(0);

    /* Raise TypeError if arg is not string */
    if ((OBJ_GET_TYPE(ps) != OBJ_TYPE_STR))
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Raise TypeError if arg is not length 1 (a character) */
    if ((((pPmString_t)ps)->length != 1))
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Get integer value of character */
    n = ((pPmString_t)ps)->val[0];
    retval = int_new(n, &pn);
    NATIVE_SET_TOS(pn);
    return retval;
    
}

PmReturn_t
nat___bi_pow(pPmFrame_t *ppframe)
{

    pPmObj_t px;
    pPmObj_t py;
    pPmObj_t pn;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 2)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    px = NATIVE_GET_LOCAL(0);
    py = NATIVE_GET_LOCAL(1);

    /* Calculate integer power */
    retval = int_pow(px, py, &pn);
    PM_RETURN_IF_ERROR(retval);

    /* Push result on stack */
    NATIVE_SET_TOS(pn);

    return retval;
    
}

PmReturn_t
nat___bi_range(pPmFrame_t *ppframe)
{

    PmReturn_t retval;
    pPmObj_t pa = C_NULL;
    pPmObj_t pb = C_NULL;
    pPmObj_t pc = C_NULL;
    pPmObj_t pi = C_NULL;
    pPmObj_t pr = C_NULL;
    int16_t i = 0;

    switch (NATIVE_GET_NUM_ARGS())
    {
        case 1:
            pa = PM_ZERO;
            pb = NATIVE_GET_LOCAL(0);
            pc = PM_ONE;
            break;

        case 2:
            pa = NATIVE_GET_LOCAL(0);
            pb = NATIVE_GET_LOCAL(1);
            pc = PM_ONE;
            break;

        case 3:
            pa = NATIVE_GET_LOCAL(0);
            pb = NATIVE_GET_LOCAL(1);
            pc = NATIVE_GET_LOCAL(2);

            /* If 3rd arg is 0, ValueError */
            if (((pPmInt_t)pc)->val == 0)
            {
                PM_RAISE(retval, PM_RET_EX_VAL);
                return retval;
            }
            break;

        default:
            /* If wrong number of args, raise TypeError */
            PM_RAISE(retval, PM_RET_EX_TYPE);
            return retval;
    }

    /* Allocate list */
    retval = list_new(&pr);
    PM_RETURN_IF_ERROR(retval);

    /* Iterate depending on counting direction */
    if (((pPmInt_t)pc)->val > 0)
    {
        for (i = ((pPmInt_t)pa)->val;
             i < ((pPmInt_t)pb)->val;
             i += ((pPmInt_t)pc)->val)
        {
            retval = int_new(i, &pi);
            PM_RETURN_IF_ERROR(retval);

            retval = list_append(pr, pi);
            PM_RETURN_IF_ERROR(retval);
        }
    }
    else
    {
        for (i = ((pPmInt_t)pa)->val;
             i > ((pPmInt_t)pb)->val;
             i += ((pPmInt_t)pc)->val)
        {
            retval = int_new(i, &pi);
            PM_RETURN_IF_ERROR(retval);

            retval = list_append(pr, pi);
            PM_RETURN_IF_ERROR(retval);
        }
    }

    /* Return list */
    NATIVE_SET_TOS(pr);
    return retval;
    
}

PmReturn_t
nat___bi_sum(pPmFrame_t *ppframe)
{

    pPmObj_t ps;
    pPmObj_t pn;
    pPmObj_t po;
    int32_t n;
    uint16_t len;
    uint16_t i;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Get the length of the sequence */
    ps = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(ps) == OBJ_TYPE_TUP)
    {
        len = ((pPmTuple_t)ps)->length;
    }
    else if (OBJ_GET_TYPE(ps) == OBJ_TYPE_LST)
    {
        len = ((pPmTuple_t)ps)->length;
    }

    /* Raise TypeError if arg is not a sequence */
    else
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Calculate the sum of the sequence */
    n = 0;
    for (i = 0; i < len; i++)
    {
        retval = seq_getSubscript(ps, i, &po);

        /* Raise TypeError if item is not an integer */
        if (OBJ_GET_TYPE(po) != OBJ_TYPE_INT)
        {
            PM_RAISE(retval, PM_RET_EX_TYPE);
            return retval;
        }

        /* Add value to sum */
        n += ((pPmInt_t)po)->val;
    }

    retval = int_new(n, &pn);
    NATIVE_SET_TOS(pn);
    return retval;
    
}

PmReturn_t
nat___bi_list(pPmFrame_t *ppframe)
{

    pPmObj_t piter;
    pPmObj_t plist;
    pPmObj_t pobj;
    PmReturn_t retval;
    uint16_t i = 0;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* create a new list */
    retval = list_new(&plist);
    PM_RETURN_IF_ERROR(retval);

    /* Get the iter to be listed */
    piter = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(piter) == OBJ_TYPE_STR)
    {
        /* Get each char from the string, pack it into an int, and add it to the list */
        for (; i < ((pPmString_t)piter)->length; i++)
        {
            retval = int_new((((pPmString_t)piter)->val)[i], &pobj);
            PM_RETURN_IF_ERROR(retval);
            retval = list_append(plist, pobj);
            PM_RETURN_IF_ERROR(retval);
        }
    }
    else if (OBJ_GET_TYPE(piter) == OBJ_TYPE_TUP)
    {
        /* Get each obj from the tuple and add it to the list */
        for (; i < ((pPmTuple_t)piter)->length; i++)
        {
            retval = list_append(plist, (((pPmTuple_t)piter)->val)[i]);
            PM_RETURN_IF_ERROR(retval);
        }
    }
    /* Raise TypeError if arg is not a string or tuple (who would need a list to be listified?) */
    else
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    NATIVE_SET_TOS(plist);
    return retval;
    
}

PmReturn_t
nat___bi_type(pPmFrame_t *ppframe)
{

    PmReturn_t retval;
    pPmObj_t po = C_NULL;
    pPmObj_t pr = C_NULL;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Get arg */
    po = NATIVE_GET_LOCAL(0);

    /* Create int from type enum */
    retval = int_new(OBJ_GET_TYPE(po), &pr);
    NATIVE_SET_TOS(pr);
    return retval;
    
}

PmReturn_t
nat___bi_Co(pPmFrame_t *ppframe)
{

    PmReturn_t retval;
    pPmObj_t pimg;
    pPmObj_t pco;
    uint8_t const *imgaddr;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Raise ValueError if arg is not a string */
    pimg = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(pimg) != OBJ_TYPE_STR)
    {
        PM_RAISE(retval, PM_RET_EX_VAL);
        return retval;
    }

    /* Create a code object from the image */
    imgaddr = (uint8_t *)&((pPmString_t)pimg)->val;
    retval = obj_loadFromImg(MEMSPACE_RAM, &imgaddr, &pco);
    PM_RETURN_IF_ERROR(retval);

    /* Return the code object */
    NATIVE_SET_TOS(pco);
    return retval;
    
}

PmReturn_t
nat___bi_set_type(pPmFrame_t *ppframe)
{

    PmReturn_t retval = PM_RET_OK;
    pPmObj_t po = C_NULL;
    pPmObj_t newType = C_NULL;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 2)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Get arg */
    po = NATIVE_GET_LOCAL(0);
    newType = NATIVE_GET_LOCAL(1);

    /* ensure newType is an int */
    if (OBJ_GET_TYPE(newType) != OBJ_TYPE_INT)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    OBJ_SET_TYPE(po, ((pPmInt_t)newType)->val);
    return retval;
    
}

PmReturn_t
nat_sys_exit(pPmFrame_t *ppframe)
{

    pPmObj_t pval = C_NULL;
    PmReturn_t retval;

    /* If no arg given, assume return 0 */
    if (NATIVE_GET_NUM_ARGS() == 0)
    {
        NATIVE_SET_TOS(PM_ZERO);
    }

    /* If 1 arg given, put it on stack */
    else if (NATIVE_GET_NUM_ARGS() == 1)
    {
        pval = NATIVE_GET_LOCAL(0);
        NATIVE_SET_TOS(pval);
    }

    /* If wrong number of args, raise TypeError */
    else
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Raise the SystemExit exception */
    PM_RAISE(retval, PM_RET_EX_EXIT);
    return retval;
    
}

PmReturn_t
nat_sys_getb(pPmFrame_t *ppframe)
{

    uint8_t b;
    pPmObj_t pb;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 0)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    retval = plat_getByte(&b);
    PM_RETURN_IF_ERROR(retval);

    retval = int_new((int32_t)b, &pb);
    NATIVE_SET_TOS(pb);
    return retval;
    
}

PmReturn_t
nat_sys_heap(pPmFrame_t *ppframe)
{

    PmReturn_t retval;
    pPmObj_t pavail;
    pPmObj_t pmax;
    pPmObj_t ptup;
    uint16_t avail;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 0)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Allocate a tuple to store the return values */
    retval = tuple_new(2, &ptup);
    PM_RETURN_IF_ERROR(retval);

    /* Get the maximum heap size */
    retval = int_new(HEAP_SIZE, &pmax);
    PM_RETURN_IF_ERROR(retval);

    /* Allocate an int to hold the amount of heap available */
    retval = heap_getAvail(&avail);
    PM_RETURN_IF_ERROR(retval);
    retval = int_new(avail - sizeof(PmInt_t), &pavail);
    PM_RETURN_IF_ERROR(retval);

    /* Put the two heap values in the tuple */
    ((pPmTuple_t)ptup)->val[0] = pavail;
    ((pPmTuple_t)ptup)->val[1] = pmax;

    /* Return the tuple on the stack */
    NATIVE_SET_TOS(ptup);

    return retval;
    
}

PmReturn_t
nat_sys_putb(pPmFrame_t *ppframe)
{

    uint8_t b;
    pPmObj_t pb;
    PmReturn_t retval;

    pb = NATIVE_GET_LOCAL(0);

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* If arg is not an int, raise TypeError */
    if (OBJ_GET_TYPE(pb) != OBJ_TYPE_INT)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    b = ((pPmInt_t)pb)->val & 0xFF;
    retval = plat_putByte(b);
    NATIVE_SET_TOS(PM_NONE);
    return retval;
    
}

PmReturn_t
nat_sys_time(pPmFrame_t *ppframe)
{

    uint32_t t;
    pPmObj_t pt;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 0)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* Get the system time (milliseconds since init) */
    retval = plat_getMsTicks(&t);
    PM_RETURN_IF_ERROR(retval);

    /*
     * Raise ValueError if there is an overflow
     * (plat_getMsTicks is unsigned; int is signed)
     */
    if ((int32_t)t < 0)
    {
        PM_RAISE(retval, PM_RET_EX_VAL);
        return retval;
    }

    /* Return an int object with the time value */
    retval = int_new((int32_t)t, &pt);
    NATIVE_SET_TOS(pt);
    return retval;
    
}

PmReturn_t
nat_sys_print_vm_state(pPmFrame_t *ppframe)
{


    heap_gcRun();
    heap_gcPrintFreelist();

    return PM_RET_OK;
    
}

PmReturn_t
nat_sys_registerCallback(pPmFrame_t *ppframe)
{

    pPmObj_t paddr;
    pPmObj_t pfunc;
    PmReturn_t retval;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 2)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    paddr = NATIVE_GET_LOCAL(0);

    /* If first arg is not an int, raise TypeError */
    if (OBJ_GET_TYPE(paddr) != OBJ_TYPE_INT)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    pfunc = NATIVE_GET_LOCAL(1);

    /* If second arg is not a function, raise TypeError */
    if (OBJ_GET_TYPE(pfunc) != OBJ_TYPE_FXN)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    retval = dict_setItem((pPmObj_t)gVmGlobal.callbacks, paddr, pfunc);
    return retval;
    
}

PmReturn_t
nat_thread_spawn(pPmFrame_t *ppframe)
{

    PmReturn_t retval;
    pPmObj_t pf;

    /* If wrong number of args, raise TypeError */
    if (NATIVE_GET_NUM_ARGS() != 1)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    /* If arg is not a function, raise TypeError */
    pf = NATIVE_GET_LOCAL(0);
    if (OBJ_GET_TYPE(pf) != OBJ_TYPE_FXN
        && OBJ_GET_TYPE(pf) != OBJ_TYPE_MTH)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    retval = interp_addThread((pPmFunc_t)pf);
    return retval;
    
}

PmReturn_t
nat_thread_wait(pPmFrame_t *ppframe)
{

    /* Set the reschedule flag to true */
    VM_SET_RESCHEDULE(1);
    return PM_RET_OK;
    
}

PmReturn_t
nat_thread_lock(pPmFrame_t *ppframe)
{

    /* Set the atomic flag to true */
    VM_SET_ATOMIC(1);
    return PM_RET_OK;
    
}

PmReturn_t
nat_thread_unlock(pPmFrame_t *ppframe)
{

    /* Set the atmoic flag to false */
    VM_SET_ATOMIC(0);
    return PM_RET_OK;
    
}

PmReturn_t
nat_avr_portA(pPmFrame_t *ppframe)
{

    pPmObj_t pa;
    uint8_t ddra;
    PmReturn_t retval = PM_RET_OK;

    /* Store port A data direction register */
    ddra = DDRA;

    switch (NATIVE_GET_NUM_ARGS())
    {
        /* If no argument is present, return PORTA */
        case 0:

            /* Set port A as all inputs so it can be read */
            DDRA = 0x00;

            /* Read port A and create a Python integer from its value */
            retval = int_new((int32_t)PORTA, &pa);

            /* Return the integer on the stack */
            NATIVE_SET_TOS(pa);
            break;

        /* If one argument is present, set port A to that value */
        case 1:
            pa = NATIVE_GET_LOCAL(0);

            /* If the arg is not an integer, raise TypeError */
            if (OBJ_GET_TYPE(pa) != OBJ_TYPE_INT)
            {
                PM_RAISE(retval, PM_RET_EX_TYPE);
                break;
            }

            /* Otherwise set PORTA to the low byte of the integer value */
            PORTA = ((pPmInt_t)pa)->val;
            break;

        /* If an invalid number of args are present, raise TypeError */
        default:
            PM_RAISE(retval, PM_RET_EX_TYPE);
            break;
    }

    /* Restore port A data direction register */
    DDRA = ddra;
    return retval;
    
}

/* native function lookup table */
PmReturn_t (* std_nat_fxn_table[])(pPmFrame_t *) =
{
    nat___bi_abs,
    nat___bi_chr,
    nat___bi_eval,
    nat___bi_globals,
    nat___bi_id,
    nat___bi_len,
    nat___bi_locals,
    nat___bi_ord,
    nat___bi_pow,
    nat___bi_range,
    nat___bi_sum,
    nat___bi_list,
    nat___bi_type,
    nat___bi_Co,
    nat___bi_set_type,
    nat_sys_exit,
    nat_sys_getb,
    nat_sys_heap,
    nat_sys_putb,
    nat_sys_time,
    nat_sys_print_vm_state,
    nat_sys_registerCallback,
    nat_thread_spawn,
    nat_thread_wait,
    nat_thread_lock,
    nat_thread_unlock,
    nat_avr_portA,
};
